# 5. Exploitation et s√©curit√© (Mod√®le d'architecture d'exploitation voir MAE.md)

## 5.1 Mod√®le de s√©curit√© multi-utilisateurs

Cette section d√©finit le mod√®le de s√©curit√© sp√©cifiquement con√ßu pour l'architecture multi-utilisateurs avec gestion OAuth progressive.

### 5.1.1 Principes de s√©curit√© fondamentaux

**Vue - Mod√®le de s√©curit√© multi-utilisateurs**

```mermaid
graph TB
    subgraph "Couche d'authentification"
        AUTH[üîê Authentification Multi-utilisateurs]
        MFA[üîí MFA (TOTP + SMS)]
        OAUTH_AUTH[üîë Authentification OAuth progressive]
    end

    subgraph "Couche d'autorisation"
        RBAC[üë• RBAC Multi-utilisateurs]
        ABAC[üè∑Ô∏è ABAC bas√© sur les attributs]
        OAUTH_SCOPES[üìã Validation des scopes OAuth]
    end

    subgraph "Couche d'isolation"
        USER_ISOLATION[üö´ Isolation stricte des donn√©es]
        OAUTH_ISOLATION[üîí Isolation des tokens OAuth]
        DATA_ENCRYPTION[üîê Chiffrement des donn√©es]
    end

    subgraph "Couche de monitoring"
        AUDIT[üìä Audit trail complet]
        ALERTS[üö® Alertes de s√©curit√©]
        COMPLIANCE[üìã Conformit√© GDPR/CCPA]
    end

    AUTH --> MFA
    AUTH --> OAUTH_AUTH
    OAUTH_AUTH --> OAUTH_SCOPES

    RBAC --> ABAC
    ABAC --> OAUTH_SCOPES

    USER_ISOLATION --> OAUTH_ISOLATION
    OAUTH_ISOLATION --> DATA_ENCRYPTION

    AUDIT --> ALERTS
    ALERTS --> COMPLIANCE
```

**Explication du mod√®le de s√©curit√©**:

Le mod√®le de s√©curit√© multi-utilisateurs repose sur **quatre couches fondamentales** qui assurent l'isolation stricte des donn√©es et la gestion s√©curis√©e des int√©grations OAuth :

1. **Couche d'authentification** : Validation de l'identit√© avec MFA et OAuth progressif
2. **Couche d'autorisation** : Contr√¥le d'acc√®s bas√© sur les r√¥les et attributs
3. **Couche d'isolation** : S√©paration stricte des donn√©es par utilisateur
4. **Couche de monitoring** : Surveillance continue et conformit√© r√©glementaire

### 5.1.2 Strat√©gie d'isolation multi-utilisateurs

#### **5.1.2.1 Isolation des donn√©es utilisateur**

**Principe fondamental** : **Aucune donn√©e utilisateur ne peut √™tre accessible par un autre utilisateur**

**M√©canismes d'isolation**:

- **Isolation au niveau base de donn√©es** : Clause `WHERE user_id = ?` sur toutes les requ√™tes
- **Isolation au niveau cache** : Pr√©fixage des cl√©s Redis par `user_id`
- **Isolation au niveau fichiers** : S√©paration des uploads par r√©pertoire utilisateur
- **Isolation au niveau sessions** : Tokens JWT avec `user_id` int√©gr√©

**Exemple d'impl√©mentation**:

```sql
-- Requ√™te s√©curis√©e avec isolation utilisateur
SELECT * FROM ltm_memories
WHERE user_id = $1
AND memory_type = $2;

-- Insertion avec validation utilisateur
INSERT INTO user_goals (user_id, title, description)
VALUES ($1, $2, $3)
RETURNING id;
```

#### **5.1.2.2 Isolation des int√©grations OAuth**

**Principe OAuth** : **Chaque utilisateur g√®re ses propres connexions OAuth ind√©pendamment**

**M√©canismes d'isolation OAuth**:

- **Tokens OAuth isol√©s** : Stockage s√©par√© par utilisateur et par service
- **Scopes OAuth individuels** : Permissions sp√©cifiques √† chaque utilisateur
- **Consentements OAuth s√©par√©s** : Gestion ind√©pendante des autorisations
- **R√©vocation OAuth granulaire** : Possibilit√© de r√©voquer l'acc√®s par service

**Structure de donn√©es OAuth isol√©e**:

```sql
-- Table des int√©grations OAuth par utilisateur
CREATE TABLE oauth_integrations (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    service_name VARCHAR(50) NOT NULL, -- 'notion', 'google', 'microsoft'
    access_token TEXT NOT NULL,
    refresh_token TEXT,
    expires_at TIMESTAMP,
    scopes TEXT[] NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),

    -- Contrainte d'unicit√© par utilisateur et service
    UNIQUE(user_id, service_name)
);

-- Index pour l'isolation et la performance
CREATE INDEX idx_oauth_integrations_user_service ON oauth_integrations(user_id, service_name);
CREATE INDEX idx_oauth_integrations_active ON oauth_integrations(user_id, is_active);
```

### 5.1.3 Gestion des acc√®s et permissions

#### **5.1.3.1 RBAC (Role-Based Access Control) Multi-utilisateurs**

**Tableau 5.1.1 - Matrice des permissions RBAC multi-utilisateurs**

| R√¥le                      | Profil utilisateur         | Profil premium             | Profil administrateur       | Profil syst√®me           |
| ------------------------- | -------------------------- | -------------------------- | --------------------------- | ------------------------ |
| **Donn√©es personnelles**  | R/W (propres donn√©es)      | R/W (propres donn√©es)      | R (toutes les donn√©es)      | R (donn√©es syst√®me)      |
| **Int√©grations OAuth**    | R/W (propres int√©grations) | R/W (propres int√©grations) | R (toutes les int√©grations) | R (int√©grations syst√®me) |
| **Tokens OAuth**          | R (propres tokens)         | R (propres tokens)         | R (tous les tokens)         | R (tokens syst√®me)       |
| **M√©triques utilisateur** | R (propres m√©triques)      | R (propres m√©triques)      | R (toutes les m√©triques)    | R (m√©triques syst√®me)    |
| **Configuration syst√®me** | Aucun acc√®s                | Aucun acc√®s                | R/W (configuration)         | R/W (configuration)      |
| **Logs syst√®me**          | Aucun acc√®s                | Aucun acc√®s                | R (tous les logs)           | R/W (tous les logs)      |

#### **5.1.3.2 ABAC (Attribute-Based Access Control)**

**Politiques ABAC pour l'isolation multi-utilisateurs**:

```python
# Politique d'isolation stricte des donn√©es
def check_data_access(user, resource, action):
    """V√©rification de l'acc√®s aux donn√©es avec isolation stricte"""

    # Politique 1: Isolation des donn√©es par utilisateur
    if resource.owner_id != user.id and user.role != "administrator":
        return False, "Acc√®s interdit - donn√©es d'un autre utilisateur"

    # Politique 2: Validation des scopes OAuth pour les actions sensibles
    if action.requires_oauth and not user.has_valid_oauth_scope(resource.service, action.scope):
        return False, "Scope OAuth insuffisant pour cette action"

    # Politique 3: V√©rification de l'activation granulaire des fonctionnalit√©s
    if not user.has_feature_enabled(resource.feature):
        return False, "Fonctionnalit√© non activ√©e pour cet utilisateur"

    return True, "Acc√®s autoris√©"

# Politique de gestion des int√©grations OAuth
def check_oauth_access(user, oauth_service, action):
    """V√©rification de l'acc√®s aux int√©grations OAuth"""

    # Politique 1: Seul le propri√©taire peut g√©rer ses int√©grations OAuth
    if action in ["create", "update", "delete"] and not user.can_manage_oauth():
        return False, "Gestion des int√©grations OAuth non autoris√©e"

    # Politique 2: V√©rification des limites d'int√©grations OAuth
    if action == "create" and user.oauth_integration_count >= user.oauth_limit:
        return False, "Limite d'int√©grations OAuth atteinte"

    # Politique 3: Validation des scopes demand√©s
    if not user.can_request_oauth_scopes(oauth_service, action.scopes):
        return False, "Scopes OAuth demand√©s non autoris√©s"

    return True, "Acc√®s OAuth autoris√©"
```

### 5.1.4 S√©curit√© des int√©grations OAuth

#### **5.1.4.1 Gestion s√©curis√©e des tokens OAuth**

**Chiffrement des tokens OAuth**:

```python
# Chiffrement des tokens OAuth au repos
from cryptography.fernet import Fernet
import os

class OAuthTokenManager:
    def __init__(self):
        self.cipher = Fernet(os.getenv('OAUTH_ENCRYPTION_KEY'))

    def encrypt_token(self, token: str) -> str:
        """Chiffrement d'un token OAuth"""
        return self.cipher.encrypt(token.encode()).decode()

    def decrypt_token(self, encrypted_token: str) -> str:
        """D√©chiffrement d'un token OAuth"""
        return self.cipher.decrypt(encrypted_token.encode()).decode()

    def store_token(self, user_id: int, service: str, token: str):
        """Stockage s√©curis√© d'un token OAuth"""
        encrypted_token = self.encrypt_token(token)

        # Stockage avec isolation utilisateur
        query = """
        INSERT INTO oauth_integrations (user_id, service_name, access_token)
        VALUES ($1, $2, $3)
        ON CONFLICT (user_id, service_name)
        DO UPDATE SET access_token = $3, updated_at = NOW()
        """
        execute_query(query, (user_id, service, encrypted_token))

    def retrieve_token(self, user_id: int, service: str) -> str:
        """R√©cup√©ration s√©curis√©e d'un token OAuth"""
        query = """
        SELECT access_token FROM oauth_integrations
        WHERE user_id = $1 AND service_name = $2 AND is_active = true
        """
        result = execute_query(query, (user_id, service))

        if result:
            encrypted_token = result[0]['access_token']
            return self.decrypt_token(encrypted_token)
        return None
```

#### **5.1.4.2 Rotation et r√©vocation des tokens OAuth**

**Politique de rotation des tokens**:

- **Access tokens** : Rotation automatique selon la politique du fournisseur
- **Refresh tokens** : Rotation lors de la r√©vocation ou expiration
- **Tokens compromis** : R√©vocation imm√©diate et r√©g√©n√©ration
- **Audit des rotations** : Tra√ßabilit√© compl√®te des changements de tokens

**Proc√©dure de r√©vocation OAuth**:

```python
def revoke_oauth_integration(user_id: int, service: str):
    """R√©vocation s√©curis√©e d'une int√©gration OAuth"""

    # 1. R√©cup√©ration du token actuel
    current_token = oauth_manager.retrieve_token(user_id, service)

    # 2. R√©vocation aupr√®s du fournisseur OAuth
    if current_token:
        revoke_token_with_provider(service, current_token)

    # 3. D√©sactivation dans la base de donn√©es
    query = """
    UPDATE oauth_integrations
    SET is_active = false, updated_at = NOW()
    WHERE user_id = $1 AND service_name = $2
    """
    execute_query(query, (user_id, service))

    # 4. Audit de la r√©vocation
    audit_log.log_oauth_revocation(user_id, service, "User requested revocation")

    # 5. Notification √† l'utilisateur
    notify_user_oauth_revoked(user_id, service)
```

### 5.1.5 Monitoring et d√©tection des menaces

#### **5.1.5.1 Syst√®me d'alertes de s√©curit√© multi-utilisateurs**

**Types d'alertes OAuth**:

```python
class OAuthSecurityMonitor:
    def __init__(self):
        self.alert_thresholds = {
            'oauth_token_exposure': 1,      # Imm√©diat
            'oauth_integration_abuse': 5,    # 5 tentatives
            'cross_user_data_access': 1,     # Imm√©diat
            'oauth_rate_limit_exceeded': 10,  # 10 tentatives
            'suspicious_oauth_activity': 3    # 3 tentatives
        }

    def detect_oauth_threats(self, event):
        """D√©tection des menaces OAuth"""

        if event.type == 'oauth_token_exposure':
            if event.user_id != event.token_owner_id:
                self.raise_critical_alert('oauth_token_exposure', event)

        elif event.type == 'oauth_integration_abuse':
            if event.attempts > self.alert_thresholds['oauth_integration_abuse']:
                self.raise_high_alert('oauth_integration_abuse', event)

        elif event.type == 'cross_user_data_access':
            if event.source_user_id != event.target_user_id:
                self.raise_critical_alert('cross_user_data_access', event)

        elif event.type == 'oauth_rate_limit_exceeded':
            if event.rate > self.alert_thresholds['oauth_rate_limit_exceeded']:
                self.raise_medium_alert('oauth_rate_limit_exceeded', event)

    def raise_critical_alert(self, alert_type, event):
        """Alerte critique avec escalade imm√©diate"""
        alert = SecurityAlert(
            level='CRITICAL',
            type=alert_type,
            user_id=event.user_id,
            description=f"Menace OAuth critique d√©tect√©e: {alert_type}",
            context=event.to_dict(),
            requires_immediate_action=True
        )

        # Escalade imm√©diate
        self.escalate_critical_alert(alert)
        self.notify_security_team(alert)
        self.block_user_if_necessary(event.user_id)
```

#### **5.1.5.2 M√©triques de s√©curit√© OAuth**

**Tableau 5.1.2 - M√©triques de s√©curit√© OAuth √† surveiller**

| M√©trique                                   | Description                             | Seuil d'alerte         | Action                   |
| ------------------------------------------ | --------------------------------------- | ---------------------- | ------------------------ |
| **Tentatives de connexion OAuth √©chou√©es** | Nombre d'√©checs par utilisateur         | > 3 par heure          | Blocage temporaire       |
| **Tokens OAuth expir√©s**                   | Pourcentage de tokens expir√©s           | > 20%                  | Notification utilisateur |
| **Int√©grations OAuth inactives**           | Int√©grations non utilis√©es              | > 30 jours             | Nettoyage automatique    |
| **Tentatives d'acc√®s crois√©**              | Acc√®s aux donn√©es d'autres utilisateurs | > 0                    | Alerte imm√©diate         |
| **Utilisation abusive des APIs OAuth**     | Appels API excessifs                    | > 100/min              | Rate limiting            |
| **R√©vocations OAuth**                      | Nombre de r√©vocations par jour          | > 10% des utilisateurs | Investigation            |

### 5.1.6 Conformit√© et audit

#### **5.1.6.1 Conformit√© GDPR pour l'architecture multi-utilisateurs**

**Droit √† l'oubli**:

```python
def delete_user_data_complete(user_id: int):
    """Suppression compl√®te des donn√©es utilisateur (GDPR Article 17)"""

    # 1. R√©vocation de toutes les int√©grations OAuth
    oauth_services = get_user_oauth_services(user_id)
    for service in oauth_services:
        revoke_oauth_integration(user_id, service)

    # 2. Suppression des donn√©es personnelles
    tables_to_clean = [
        'users', 'ltm_memories', 'user_goals', 'tasks',
        'oauth_integrations', 'user_settings', 'expenses'
    ]

    for table in tables_to_clean:
        query = f"DELETE FROM {table} WHERE user_id = $1"
        execute_query(query, (user_id,))

    # 3. Audit de la suppression
    audit_log.log_gdpr_deletion(user_id, "Complete user data deletion")

    # 4. Confirmation de suppression
    return {
        "status": "success",
        "message": "Toutes les donn√©es utilisateur ont √©t√© supprim√©es",
        "deletion_timestamp": datetime.now().isoformat()
    }
```

**Portabilit√© des donn√©es**:

```python
def export_user_data_gdpr(user_id: int):
    """Export des donn√©es utilisateur (GDPR Article 20)"""

    # 1. Collecte de toutes les donn√©es utilisateur
    user_data = {
        "profile": get_user_profile(user_id),
        "memories": get_user_memories(user_id),
        "goals": get_user_goals(user_id),
        "tasks": get_user_tasks(user_id),
        "oauth_integrations": get_user_oauth_summary(user_id),
        "expenses": get_user_expenses(user_id),
        "notes": get_user_notes(user_id)
    }

    # 2. Formatage en JSON structur√©
    export_data = {
        "user_id": user_id,
        "export_timestamp": datetime.now().isoformat(),
        "data": user_data
    }

    # 3. Chiffrement de l'export
    encrypted_export = encrypt_export_data(export_data)

    # 4. Audit de l'export
    audit_log.log_gdpr_export(user_id, "User data export requested")

    return encrypted_export
```

#### **5.1.6.2 Audit trail complet**

**Structure de l'audit trail**:

```sql
-- Table d'audit des actions utilisateur
CREATE TABLE user_audit_log (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    action_type VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50),
    resource_id INTEGER,
    action_details JSONB,
    ip_address INET,
    user_agent TEXT,
    timestamp TIMESTAMP DEFAULT NOW(),

    -- Index pour la performance et l'isolation
    INDEX idx_audit_user_timestamp (user_id, timestamp),
    INDEX idx_audit_action_type (action_type, timestamp)
);

-- Table d'audit des actions OAuth
CREATE TABLE oauth_audit_log (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    service_name VARCHAR(50) NOT NULL,
    action_type VARCHAR(100) NOT NULL,
    oauth_details JSONB,
    ip_address INET,
    user_agent TEXT,
    timestamp TIMESTAMP DEFAULT NOW(),

    -- Index pour la performance et l'isolation
    INDEX idx_oauth_audit_user_service (user_id, service_name, timestamp),
    INDEX idx_oauth_audit_action (action_type, timestamp)
);
```

## 5.2 Mod√®le d'exploitation s√©curis√©

### 5.2.1 Proc√©dures op√©rationnelles de s√©curit√©

#### **5.2.1.1 Gestion des incidents de s√©curit√© OAuth**

**Proc√©dure de r√©ponse aux incidents OAuth**:

1. **D√©tection** : Monitoring automatique et alertes
2. **Classification** : Criticit√© bas√©e sur l'impact utilisateur
3. **Containement** : Isolation imm√©diate de la menace
4. **Investigation** : Analyse forensique et identification de la cause
5. **R√©cup√©ration** : Restauration des services et donn√©es
6. **Post-mortem** : Documentation et am√©lioration des proc√©dures

#### **5.2.1.2 Maintenance s√©curis√©e des int√©grations OAuth**

**Proc√©dures de maintenance**:

- **Rotation des cl√©s OAuth** : Changement p√©riodique des secrets clients
- **Mise √† jour des scopes** : Validation des permissions requises
- **Tests de s√©curit√©** : Validation des int√©grations apr√®s modification
- **Documentation** : Mise √† jour des proc√©dures op√©rationnelles

### 5.2.2 Formation et sensibilisation

#### **5.2.2.1 Formation de l'√©quipe de s√©curit√©**

**Modules de formation**:

- **Architecture multi-utilisateurs** : Compr√©hension de l'isolation des donn√©es
- **Gestion OAuth** : Bonnes pratiques de s√©curit√© OAuth
- **D√©tection des menaces** : Identification des comportements suspects
- **R√©ponse aux incidents** : Proc√©dures d'urgence et escalade

#### **5.2.2.2 Sensibilisation des utilisateurs**

**Programme de sensibilisation**:

- **S√©curit√© des int√©grations OAuth** : Gestion des autorisations
- **Protection des donn√©es personnelles** : Bonnes pratiques de s√©curit√©
- **Reconnaissance des menaces** : Identification des tentatives de phishing
- **Signalement des incidents** : Proc√©dures de reporting

## 5.3 √âvaluation et am√©lioration continue

### 5.3.1 Tests de s√©curit√© r√©guliers

#### **5.3.1.1 Tests de p√©n√©tration OAuth**

**Fr√©quence** : Trimestrielle

**Port√©e** :

- Validation de l'isolation multi-utilisateurs
- Tests des int√©grations OAuth
- Validation de la gestion des tokens
- Tests de contournement des contr√¥les d'acc√®s

#### **5.3.1.2 Tests d'int√©grit√© des donn√©es**

**Fr√©quence** : Mensuelle

**Port√©e** :

- Validation de l'isolation des donn√©es par utilisateur
- Tests de fuite de donn√©es entre utilisateurs
- Validation du chiffrement des tokens OAuth
- Tests de r√©cup√©ration des donn√©es

### 5.3.2 M√©triques de performance de s√©curit√©

#### **5.3.2.1 KPIs de s√©curit√©**

- **Temps de d√©tection des menaces** : < 5 minutes
- **Temps de r√©ponse aux incidents** : < 30 minutes
- **Taux de faux positifs** : < 5%
- **Couverture des tests de s√©curit√©** : > 90%

#### **5.3.2.2 Am√©lioration continue**

**Processus d'am√©lioration**:

1. **Collecte des m√©triques** : Surveillance continue des indicateurs
2. **Analyse des tendances** : Identification des am√©liorations possibles
3. **Planification des am√©liorations** : Priorisation des actions
4. **Impl√©mentation** : Mise en ≈ìuvre des am√©liorations
5. **Validation** : Mesure de l'impact des am√©liorations
6. **Documentation** : Mise √† jour des proc√©dures
