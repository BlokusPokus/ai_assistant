# Task 037.2: Enhanced Features & Production Readiness - Background Task System

## **üìã Task Overview**

**Task ID**: 037.2  
**Task Name**: Enhanced Features & Production Readiness - Background Task System  
**Parent Task**: 037 - General-Purpose Background Task System Implementation  
**Phase**: 2.3 - API & Backend Services  
**Module**: 2.3.2 - Background Task System  
**Status**: üîÑ **WAITING FOR PREREQUISITE**  
**Target Start Date**: After Task 037.1 completion  
**Effort Estimate**: 2 days  
**Dependencies**: Task 037.1 (Core Infrastructure & Migration) üîÑ **IN PROGRESS**

## **üéØ Task Objectives**

### **Primary Goal**

Enhance the background task system foundation established in Task 037.1 by implementing:

- Advanced scheduling and monitoring capabilities
- Production-ready Docker configurations
- Comprehensive testing and validation
- Performance optimization and resource management

### **Success Criteria**

- ‚úÖ Enhanced monitoring provides actionable insights
- ‚úÖ Advanced scheduling supports complex task patterns
- ‚úÖ Docker configurations support production deployment
- ‚úÖ Comprehensive testing validates all functionality
- ‚úÖ System is production-ready with monitoring and alerting

## **üîç Current State Analysis**

### **Prerequisites from Task 037.1 (What We'll Have)**

```
src/personal_assistant/workers/
‚îú‚îÄ‚îÄ celery_app.py             # Central Celery application ‚úÖ
‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py           # Task registry ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ ai_tasks.py           # AI task processing ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ email_tasks.py        # Email processing tasks ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ file_tasks.py         # File management tasks ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ sync_tasks.py         # API synchronization tasks ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ maintenance_tasks.py  # System maintenance tasks ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ base_tasks.py         # Base task classes and utilities ‚úÖ
‚îú‚îÄ‚îÄ schedulers/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py           # Scheduler registry ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ ai_scheduler.py       # AI task scheduling logic ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ base_scheduler.py     # Base scheduler classes ‚úÖ
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py           # Utility registry ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ task_monitoring.py    # Basic task monitoring ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ error_handling.py     # Basic error handling ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ health_check.py       # Basic health checks ‚úÖ
‚îî‚îÄ‚îÄ __init__.py               # Worker system initialization ‚úÖ
```

**Current Capabilities (Post-Task 037.1)**:

- ‚úÖ Basic task separation and routing
- ‚úÖ New task types implemented
- ‚úÖ Basic monitoring and error handling
- ‚úÖ Clean, modular architecture

**Enhancements Needed (Task 037.2)**:

- ‚ùå **Advanced Scheduling**: Complex scheduling patterns and dependencies
- ‚ùå **Enhanced Monitoring**: Detailed metrics, alerting, and dashboards
- ‚ùå **Production Docker**: Multi-worker configurations and resource management
- ‚ùå **Comprehensive Testing**: Unit, integration, and performance testing
- ‚ùå **Performance Optimization**: Resource tuning and scaling strategies

### **Target Implementation (What We Want)**

```
src/personal_assistant/workers/
‚îú‚îÄ‚îÄ celery_app.py             # Enhanced Celery application with advanced config
‚îú‚îÄ‚îÄ tasks/                    # ‚úÖ Already implemented in Task 037.1
‚îú‚îÄ‚îÄ schedulers/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py           # ‚úÖ Already implemented
‚îÇ   ‚îú‚îÄ‚îÄ ai_scheduler.py       # ‚úÖ Already implemented
‚îÇ   ‚îú‚îÄ‚îÄ email_scheduler.py    # üîÑ Enhanced with advanced patterns
‚îÇ   ‚îú‚îÄ‚îÄ maintenance_scheduler.py # üîÑ Enhanced with advanced patterns
‚îÇ   ‚îú‚îÄ‚îÄ base_scheduler.py     # ‚úÖ Already implemented
‚îÇ   ‚îî‚îÄ‚îÄ dependency_scheduler.py # üÜï New: handles task dependencies
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py           # ‚úÖ Already implemented
‚îÇ   ‚îú‚îÄ‚îÄ task_monitoring.py    # üîÑ Enhanced with detailed metrics
‚îÇ   ‚îú‚îÄ‚îÄ error_handling.py     # üîÑ Enhanced with advanced error handling
‚îÇ   ‚îú‚îÄ‚îÄ health_check.py       # ‚úÖ Already implemented
‚îÇ   ‚îú‚îÄ‚îÄ metrics.py            # üÜï New: detailed performance metrics
‚îÇ   ‚îú‚îÄ‚îÄ alerting.py           # üÜï New: alert system for failures
‚îÇ   ‚îî‚îÄ‚îÄ performance.py        # üÜï New: performance optimization utilities
‚îú‚îÄ‚îÄ docker/                   # üÜï New: production Docker configurations
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.prod.yml # Enhanced production setup
‚îÇ   ‚îú‚îÄ‚îÄ worker-configs/       # Worker-specific configurations
‚îÇ   ‚îî‚îÄ‚îÄ monitoring/           # Monitoring stack integration
‚îî‚îÄ‚îÄ tests/                    # üÜï New: comprehensive test suite
    ‚îú‚îÄ‚îÄ unit/                 # Unit tests for all components
    ‚îú‚îÄ‚îÄ integration/          # Integration tests
    ‚îî‚îÄ‚îÄ performance/          # Performance and load tests
```

## **üìä Implementation Plan**

### **Phase 1: Enhanced Scheduling and Monitoring (Day 1)**

#### **Step 1.1: Advanced Scheduler Implementation**

```python
# workers/schedulers/dependency_scheduler.py
"""
Dependency Scheduler for Complex Task Patterns

Handles task dependencies, conditional execution, and
complex scheduling patterns beyond simple cron schedules.
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

@dataclass
class TaskDependency:
    """Represents a task dependency relationship."""
    task_id: str
    depends_on: List[str]
    condition: Optional[str] = None
    timeout: Optional[timedelta] = None

class DependencyScheduler:
    """Manages complex task dependencies and execution order."""

    def __init__(self):
        self.dependencies: Dict[str, TaskDependency] = {}
        self.execution_graph = {}

    def add_dependency(self, dependency: TaskDependency):
        """Add a new task dependency."""
        self.dependencies[dependency.task_id] = dependency
        self._update_execution_graph()

    def get_execution_order(self) -> List[str]:
        """Get the optimal execution order for dependent tasks."""
        # TODO: Implement topological sorting for dependencies
        pass

    def check_dependencies_met(self, task_id: str) -> bool:
        """Check if all dependencies for a task are satisfied."""
        # TODO: Implement dependency checking logic
        pass
```

#### **Step 1.2: Enhanced Monitoring and Metrics**

```python
# workers/utils/metrics.py
"""
Enhanced Task Metrics Collection

Provides detailed performance metrics, resource usage tracking,
and performance optimization insights.
"""

import time
import psutil
import threading
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from dataclasses import dataclass, field
from collections import defaultdict

@dataclass
class TaskMetrics:
    """Comprehensive metrics for a single task execution."""
    task_id: str
    task_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    execution_time: Optional[float] = None
    memory_usage: Optional[float] = None
    cpu_usage: Optional[float] = None
    status: str = "running"
    error: Optional[str] = None
    retry_count: int = 0
    queue_time: Optional[float] = None

class MetricsCollector:
    """Collects and aggregates task execution metrics."""

    def __init__(self):
        self.metrics: Dict[str, TaskMetrics] = {}
        self.aggregate_stats = defaultdict(list)
        self.lock = threading.Lock()

    def start_task(self, task_id: str, task_name: str) -> str:
        """Start tracking a new task execution."""
        with self.lock:
            metrics = TaskMetrics(
                task_id=task_id,
                task_name=task_name,
                start_time=datetime.utcnow()
            )
            self.metrics[task_id] = metrics
            return task_id

    def end_task(self, task_id: str, status: str = "completed", error: Optional[str] = None):
        """End tracking a task execution."""
        with self.lock:
            if task_id in self.metrics:
                metrics = self.metrics[task_id]
                metrics.end_time = datetime.utcnow()
                metrics.execution_time = (metrics.end_time - metrics.start_time).total_seconds()
                metrics.status = status
                metrics.error = error

                # Record aggregate statistics
                self.aggregate_stats[metrics.task_name].append(metrics.execution_time)

    def get_performance_summary(self) -> Dict[str, Any]:
        """Get performance summary for all tasks."""
        with self.lock:
            summary = {}
            for task_name, times in self.aggregate_stats.items():
                if times:
                    summary[task_name] = {
                        'count': len(times),
                        'avg_time': sum(times) / len(times),
                        'min_time': min(times),
                        'max_time': max(times),
                        'total_time': sum(times)
                    }
            return summary
```

#### **Step 1.3: Advanced Error Handling and Alerting**

```python
# workers/utils/alerting.py
"""
Task Failure Alerting System

Monitors task execution and sends alerts for failures,
performance issues, and system problems.
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

@dataclass
class AlertRule:
    """Defines when and how to send alerts."""
    name: str
    condition: str  # e.g., "task_failure", "performance_degradation"
    threshold: float
    window: timedelta
    channels: List[str]  # e.g., ["email", "slack", "webhook"]
    message_template: str

class AlertManager:
    """Manages task execution alerts and notifications."""

    def __init__(self):
        self.rules: List[AlertRule] = []
        self.alert_history: List[Dict] = []
        self.logger = logging.getLogger(__name__)

    def add_rule(self, rule: AlertRule):
        """Add a new alert rule."""
        self.rules.append(rule)

    def check_alerts(self, metrics: Dict[str, Any]):
        """Check if any alert conditions are met."""
        for rule in self.rules:
            if self._evaluate_rule(rule, metrics):
                self._send_alert(rule, metrics)

    def _evaluate_rule(self, rule: AlertRule, metrics: Dict[str, Any]) -> bool:
        """Evaluate if an alert rule condition is met."""
        # TODO: Implement rule evaluation logic
        pass

    def _send_alert(self, rule: AlertRule, metrics: Dict[str, Any]):
        """Send an alert through configured channels."""
        # TODO: Implement alert sending logic
        pass
```

### **Phase 2: Production Docker and Testing (Day 2)**

#### **Step 2.1: Enhanced Docker Configurations**

```yaml
# docker/docker-compose.prod.yml (enhanced)
services:
  # AI Task Worker (enhanced)
  ai_worker:
    build:
      context: ..
      dockerfile: docker/Dockerfile
      target: production
    container_name: personal_assistant_ai_worker_prod
    environment:
      - ENVIRONMENT=production
      - DEBUG=false
      - CELERY_BROKER_URL=redis://:${PROD_REDIS_PASSWORD}@redis:6379/0
      - CELERY_RESULT_BACKEND=redis://:${PROD_REDIS_PASSWORD}@redis:6379/0
      - WORKER_QUEUE=ai_tasks
      - WORKER_CONCURRENCY=1
      - WORKER_MAX_TASKS_PER_CHILD=1000
      - METRICS_ENABLED=true
      - ALERTING_ENABLED=true
    command:
      [
        "celery",
        "-A",
        "personal_assistant.workers.celery_app",
        "worker",
        "--queues=${WORKER_QUEUE}",
        "--loglevel=info",
        "--concurrency=${WORKER_CONCURRENCY}",
        "--max-tasks-per-child=${WORKER_MAX_TASKS_PER_CHILD}",
        "--prefetch-multiplier=1",
        "--without-gossip",
        "--without-mingle",
        "--without-heartbeat",
      ]
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - personal_assistant_prod_network
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: "1.0"
        reservations:
          memory: 512M
          cpus: "0.5"
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
    healthcheck:
      test:
        [
          "CMD",
          "celery",
          "-A",
          "personal_assistant.workers.celery_app",
          "inspect",
          "ping",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Email Task Worker (enhanced)
  email_worker:
    build:
      context: ..
      dockerfile: docker/Dockerfile
      target: production
    container_name: personal_assistant_email_worker_prod
    environment:
      - ENVIRONMENT=production
      - DEBUG=false
      - CELERY_BROKER_URL=redis://:${PROD_REDIS_PASSWORD}@redis:6379/0
      - CELERY_RESULT_BACKEND=redis://:${PROD_REDIS_PASSWORD}@redis:6379/0
      - WORKER_QUEUE=email_tasks
      - WORKER_CONCURRENCY=4
      - WORKER_MAX_TASKS_PER_CHILD=1000
      - METRICS_ENABLED=true
      - ALERTING_ENABLED=true
    command:
      [
        "celery",
        "-A",
        "personal_assistant.workers.celery_app",
        "worker",
        "--queues=${WORKER_QUEUE}",
        "--loglevel=info",
        "--concurrency=${WORKER_CONCURRENCY}",
        "--max-tasks-per-child=${WORKER_MAX_TASKS_PER_CHILD}",
        "--prefetch-multiplier=1",
        "--without-gossip",
        "--without-mingle",
        "--without-heartbeat",
      ]
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - personal_assistant_prod_network
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: "2.0"
        reservations:
          memory: 1G
          cpus: "1.0"
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
    healthcheck:
      test:
        [
          "CMD",
          "celery",
          "-A",
          "personal_assistant.workers.celery_app",
          "inspect",
          "ping",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Enhanced Celery Beat Scheduler
  scheduler:
    build:
      context: ..
      dockerfile: docker/Dockerfile
      target: production
    container_name: personal_assistant_scheduler_prod
    environment:
      - ENVIRONMENT=production
      - DEBUG=false
      - CELERY_BROKER_URL=redis://:${PROD_REDIS_PASSWORD}@redis:6379/0
      - CELERY_RESULT_BACKEND=redis://:${PROD_REDIS_PASSWORD}@redis:6379/0
      - SCHEDULER_ENABLED=true
      - METRICS_ENABLED=true
      - ALERTING_ENABLED=true
    command:
      [
        "celery",
        "-A",
        "personal_assistant.workers.celery_app",
        "beat",
        "--loglevel=info",
        "--scheduler=personal_assistant.workers.schedulers.enhanced_scheduler:EnhancedScheduler",
      ]
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - personal_assistant_prod_network
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: "0.5"
        reservations:
          memory: 256M
          cpus: "0.25"
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
    healthcheck:
      test:
        [
          "CMD",
          "celery",
          "-A",
          "personal_assistant.workers.celery_app",
          "inspect",
          "ping",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Monitoring Stack Integration
  prometheus:
    image: prom/prometheus:latest
    container_name: personal_assistant_prometheus_prod
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      [
        "--config.file=/etc/prometheus/prometheus.yml",
        "--storage.tsdb.path=/prometheus",
        "--web.console.libraries=/etc/prometheus/console_libraries",
        "--web.console.templates=/etc/prometheus/consoles",
        "--storage.tsdb.retention.time=200h",
        "--web.enable-lifecycle",
      ]
    networks:
      - personal_assistant_prod_network
    restart: unless-stopped

  grafana:
    image: grafana/grafana:latest
    container_name: personal_assistant_grafana_prod
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources
    networks:
      - personal_assistant_prod_network
    restart: unless-stopped
    depends_on:
      - prometheus

volumes:
  prometheus_data:
  grafana_data:

networks:
  personal_assistant_prod_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

#### **Step 2.2: Comprehensive Testing Suite**

```python
# tests/workers/test_enhanced_features.py
"""
Enhanced Features Testing Suite

Tests advanced scheduling, monitoring, and production features
implemented in Task 037.2.
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime, timedelta
import asyncio

from personal_assistant.workers.schedulers.dependency_scheduler import DependencyScheduler, TaskDependency
from personal_assistant.workers.utils.metrics import MetricsCollector, TaskMetrics
from personal_assistant.workers.utils.alerting import AlertManager, AlertRule

class TestDependencyScheduler:
    """Test advanced dependency scheduling functionality."""

    def test_add_dependency(self):
        """Test adding task dependencies."""
        scheduler = DependencyScheduler()
        dependency = TaskDependency(
            task_id="task_b",
            depends_on=["task_a"],
            condition="task_a.status == 'completed'"
        )

        scheduler.add_dependency(dependency)
        assert "task_b" in scheduler.dependencies
        assert scheduler.dependencies["task_b"] == dependency

    def test_execution_order_simple(self):
        """Test simple dependency execution order."""
        scheduler = DependencyScheduler()

        # Task B depends on Task A
        dependency = TaskDependency(
            task_id="task_b",
            depends_on=["task_a"]
        )
        scheduler.add_dependency(dependency)

        execution_order = scheduler.get_execution_order()
        assert execution_order.index("task_a") < execution_order.index("task_b")

    def test_dependency_checking(self):
        """Test dependency satisfaction checking."""
        scheduler = DependencyScheduler()
        dependency = TaskDependency(
            task_id="task_b",
            depends_on=["task_a"]
        )
        scheduler.add_dependency(dependency)

        # Initially, dependencies not met
        assert not scheduler.check_dependencies_met("task_b")

        # TODO: Mock task completion and test dependency satisfaction

class TestMetricsCollector:
    """Test enhanced metrics collection functionality."""

    def test_start_task(self):
        """Test starting task metrics collection."""
        collector = MetricsCollector()
        task_id = collector.start_task("test_task_123", "test_task")

        assert task_id in collector.metrics
        assert collector.metrics[task_id].task_name == "test_task"
        assert collector.metrics[task_id].status == "running"

    def test_end_task(self):
        """Test ending task metrics collection."""
        collector = MetricsCollector()
        task_id = collector.start_task("test_task_123", "test_task")

        # Wait a moment to ensure different timestamps
        import time
        time.sleep(0.1)

        collector.end_task(task_id, "completed")

        metrics = collector.metrics[task_id]
        assert metrics.status == "completed"
        assert metrics.end_time is not None
        assert metrics.execution_time is not None
        assert metrics.execution_time > 0

    def test_performance_summary(self):
        """Test performance summary generation."""
        collector = MetricsCollector()

        # Simulate multiple task executions
        for i in range(3):
            task_id = f"task_{i}"
            collector.start_task(task_id, "test_task")
            collector.end_task(task_id, "completed")

        summary = collector.get_performance_summary()
        assert "test_task" in summary
        assert summary["test_task"]["count"] == 3

class TestAlertManager:
    """Test task alerting functionality."""

    def test_add_alert_rule(self):
        """Test adding alert rules."""
        alert_manager = AlertManager()
        rule = AlertRule(
            name="high_failure_rate",
            condition="task_failure",
            threshold=0.1,
            window=timedelta(minutes=5),
            channels=["email"],
            message_template="Task failure rate is {rate}%"
        )

        alert_manager.add_rule(rule)
        assert len(alert_manager.rules) == 1
        assert alert_manager.rules[0].name == "high_failure_rate"

    def test_alert_evaluation(self):
        """Test alert rule evaluation."""
        alert_manager = AlertManager()
        rule = AlertRule(
            name="task_failure",
            condition="task_failure",
            threshold=1,
            window=timedelta(minutes=5),
            channels=["email"],
            message_template="Task failed: {task_name}"
        )
        alert_manager.add_rule(rule)

        # Mock metrics that should trigger alert
        metrics = {"failed_tasks": 2}

        with patch.object(alert_manager, '_send_alert') as mock_send:
            alert_manager.check_alerts(metrics)
            # TODO: Verify alert was sent based on rule evaluation

# Performance Testing
class TestPerformance:
    """Test system performance under load."""

    @pytest.mark.asyncio
    async def test_concurrent_task_execution(self):
        """Test system performance with concurrent tasks."""
        # TODO: Implement concurrent task execution test
        pass

    def test_memory_usage_under_load(self):
        """Test memory usage during high task volume."""
        # TODO: Implement memory usage testing
        pass

    def test_cpu_usage_under_load(self):
        """Test CPU usage during high task volume."""
        # TODO: Implement CPU usage testing
        pass
```

## **‚úÖ Acceptance Criteria**

### **Functional Requirements**

- ‚úÖ **Advanced Scheduling**: Complex task dependencies and conditional execution
- ‚úÖ **Enhanced Monitoring**: Detailed metrics, performance tracking, and alerting
- ‚úÖ **Production Docker**: Multi-worker configurations with resource management
- ‚úÖ **Comprehensive Testing**: Unit, integration, and performance test coverage

### **Technical Requirements**

- ‚úÖ **Performance Optimization**: Resource tuning and scaling strategies
- ‚úÖ **Error Handling**: Advanced error recovery and alerting
- ‚úÖ **Monitoring Integration**: Prometheus and Grafana integration
- ‚úÖ **Production Hardening**: Health checks, restart policies, and resource limits

### **Performance Requirements**

- ‚úÖ **Scalability**: Support for multiple worker types with independent scaling
- ‚úÖ **Resource Efficiency**: Optimized resource usage per worker type
- ‚úÖ **Monitoring**: Real-time performance metrics and alerting
- ‚úÖ **Error Recovery**: Advanced error handling and automatic recovery

## **üîß Technical Implementation Details**

### **Enhanced Celery Configuration**

```python
# workers/celery_app.py (enhanced)
"""
Enhanced Celery Application with Advanced Features

This module provides a production-ready Celery application with
advanced scheduling, monitoring, and performance optimization.
"""

import logging
import os
from celery import Celery
from celery.schedules import crontab
from celery.signals import task_prerun, task_postrun, task_failure

# Enhanced configuration
app = Celery(
    'personal_assistant_workers',
    broker=CELERY_BROKER_URL,
    backend=CELERY_RESULT_BACKEND,
)

# Enhanced task routing with priorities
app.conf.update(
    # Task routing with priorities
    task_routes={
        'personal_assistant.workers.tasks.ai_tasks.*': {
            'queue': 'ai_tasks',
            'priority': 10
        },
        'personal_assistant.workers.tasks.email_tasks.*': {
            'queue': 'email_tasks',
            'priority': 5
        },
        'personal_assistant.workers.tasks.file_tasks.*': {
            'queue': 'file_tasks',
            'priority': 3
        },
        'personal_assistant.workers.tasks.sync_tasks.*': {
            'queue': 'sync_tasks',
            'priority': 7
        },
        'personal_assistant.workers.tasks.maintenance_tasks.*': {
            'queue': 'maintenance_tasks',
            'priority': 1
        },
    },

    # Enhanced beat schedule with dependencies
    beat_schedule={
        # AI tasks (high priority)
        'process-due-ai-tasks': {
            'task': 'personal_assistant.workers.tasks.ai_tasks.process_due_ai_tasks',
            'schedule': crontab(minute='*/10'),
            'options': {'priority': 10}
        },

        # Email tasks (medium priority)
        'process-email-queue': {
            'task': 'personal_assistant.workers.tasks.email_tasks.process_email_queue',
            'schedule': crontab(minute='*/5'),
            'options': {'priority': 5}
        },

        # File tasks (low priority)
        'cleanup-temp-files': {
            'task': 'personal_assistant.workers.tasks.file_tasks.cleanup_temp_files',
            'schedule': crontab(hour=2, minute=0),
            'options': {'priority': 3}
        },

        # Sync tasks (medium-high priority)
        'sync-calendar-events': {
            'task': 'personal_assistant.workers.tasks.sync_tasks.sync_calendar_events',
            'schedule': crontab(minute=0),
            'options': {'priority': 7}
        },

        # Maintenance tasks (lowest priority)
        'cleanup-old-logs': {
            'task': 'personal_assistant.workers.tasks.maintenance_tasks.cleanup_old_logs',
            'schedule': crontab(hour=3, minute=0),
            'options': {'priority': 1}
        },
    },

    # Enhanced worker settings
    worker_prefetch_multiplier=1,
    worker_max_tasks_per_child=1000,
    worker_disable_rate_limits=False,
    worker_send_task_events=True,
    task_send_sent_event=True,
    task_ignore_result=False,
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,

    # Enhanced result backend settings
    result_expires=3600,
    result_persistent=True,
    result_chord_join_timeout=3600,
    result_chord_retry_interval=1,

    # Enhanced task settings
    task_always_eager=False,
    task_eager_propagates=True,
    task_remote_tracebacks=True,
    task_compression='gzip',
    task_acks_late=True,
    task_reject_on_worker_lost=True,

    # Enhanced monitoring
    worker_send_task_events=True,
    task_send_sent_event=True,
    task_track_started=True,
    task_time_limit=3600,
    task_soft_time_limit=3000,
)

# Enhanced signal handlers for monitoring
@task_prerun.connect
def task_prerun_handler(sender=None, task_id=None, task=None, **kwargs):
    """Handle task pre-run events for monitoring."""
    if hasattr(app, 'metrics_collector'):
        app.metrics_collector.start_task(task_id, task.name)

@task_postrun.connect
def task_postrun_handler(sender=None, task_id=None, task=None, **kwargs):
    """Handle task post-run events for monitoring."""
    if hasattr(app, 'metrics_collector'):
        status = "completed" if kwargs.get('retval') is not None else "failed"
        app.metrics_collector.end_task(task_id, status)

@task_failure.connect
def task_failure_handler(sender=None, task_id=None, exception=None, **kwargs):
    """Handle task failure events for monitoring and alerting."""
    if hasattr(app, 'metrics_collector'):
        app.metrics_collector.end_task(task_id, "failed", str(exception))

    if hasattr(app, 'alert_manager'):
        app.alert_manager.check_alerts({
            'failed_task_id': task_id,
            'error': str(exception),
            'timestamp': datetime.utcnow().isoformat()
        })

# Initialize enhanced components
if os.getenv('METRICS_ENABLED', 'false').lower() == 'true':
    from .utils.metrics import MetricsCollector
    app.metrics_collector = MetricsCollector()

if os.getenv('ALERTING_ENABLED', 'false').lower() == 'true':
    from .utils.alerting import AlertManager
    app.alert_manager = AlertManager()
```

## **üìã Task Checklist**

### **Phase 1: Enhanced Features (Day 1)**

- [ ] Implement advanced dependency scheduler
- [ ] Implement enhanced monitoring and metrics
- [ ] Implement advanced error handling and alerting
- [ ] Test enhanced features

### **Phase 2: Production Readiness (Day 2)**

- [ ] Update Docker configurations for production
- [ ] Implement comprehensive testing suite
- [ ] Test production configurations
- [ ] Validate monitoring integration

## **üö® Risk Mitigation**

### **Technical Risks**

- **Performance Impact**: Monitor performance during enhancement implementation
- **Complexity**: Ensure new features don't compromise system stability
- **Integration Issues**: Test all components work together correctly

### **Production Risks**

- **Resource Usage**: Validate resource allocation for enhanced features
- **Monitoring Overhead**: Ensure monitoring doesn't impact performance
- **Alert Fatigue**: Implement intelligent alerting to prevent noise

## **üìà Expected Benefits**

### **Operational Improvements**

- **Advanced Scheduling**: Complex task dependencies and conditional execution
- **Enhanced Monitoring**: Detailed performance insights and proactive alerting
- **Production Readiness**: Robust deployment and scaling capabilities
- **Performance Optimization**: Resource tuning and efficiency improvements

### **Development Improvements**

- **Better Debugging**: Enhanced monitoring makes issues easier to identify
- **Performance Insights**: Detailed metrics help optimize system performance
- **Production Confidence**: Comprehensive testing ensures reliability
- **Scalability**: Advanced features support future growth

## **üîó Related Documentation**

- **Prerequisite Task**: Task 037.1 - Core Infrastructure & Migration
- **Parent Task**: Task 037 - General-Purpose Background Task System Implementation
- **Roadmap Reference**: Phase 2.3.2 - Background Task System
- **Next Phase**: Phase 2.4 - User Interface Development

## **üìù Notes**

This subtask builds upon the foundation established in Task 037.1 to create a production-ready, enterprise-grade background task system. It focuses on:

1. **Enhancing existing functionality** with advanced scheduling and monitoring
2. **Production hardening** with robust Docker configurations and testing
3. **Performance optimization** through resource management and scaling
4. **Operational excellence** with comprehensive monitoring and alerting

**Success in this subtask means**:

- The background task system is production-ready
- Advanced monitoring provides actionable insights
- Comprehensive testing validates all functionality
- System can scale efficiently in production environments
- Enhanced features enable future enhancements with minimal effort

**Completion of both Task 037.1 and Task 037.2 results in**:

- A complete, production-ready background task system
- Clean separation of concerns and modular architecture
- Enhanced monitoring, alerting, and performance optimization
- Comprehensive testing and validation
- Production Docker configurations with resource management
- Foundation for future enhancements and scaling
